---
layout: post
title: nginx配置文件详解
date: 2023-03-15
tags: [运维]
description: 穷首皓经，追求梦想！
---

>欢迎关注个人公众号【好好学技术】交流学习


# 一、内存模型
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceb44063ed864217a9af2b6dc2343219~tplv-k3u1fbpfcp-zoom-1.image)

- 程序计数器
  指向当前线程所执行的字节码指令的(地址)行号。  
  `程序计数器是唯一不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。`
- 虚拟机栈  
  栈数据结构为先进后出  
  局部变量表、操作数栈、动态链接、方法出口信息。
>局部变量表主要存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）和对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）

StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。(递归死循环)

OutOfMemoryError：若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。（方法太多）

- 本地方法栈  
  调用Native 方法服务，其他和栈差不多，也可能会有StackOverFlowError和OutOfMemoryError。
- 方法区  
  用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- 堆  
  主要用来存放对象实例和数组。  
  运行时常量池也属于堆中的一部分，用于存放编译期生成的各种字面量和符号引用。  
  JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e00b133ae7a747c88d0f367710b1bdd6~tplv-k3u1fbpfcp-zoom-1.image)


堆区分为两大块，一个是Old区，一个是Young区。新生代：老年代 1:2 。  
Young区分为两大块，一个是Survivor区（S0+S1），一块是Eden区。 Eden:S0:S1=8:1:1  
S0和S1一样大，也可以叫From和To

# 二、类加载过程

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0ca8ae2b2940b0bcdeb06f0e7e09dd~tplv-k3u1fbpfcp-watermark.image?)

## 1、加载

”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：

（1）通过一个类的全限定名来获取其定义的二进制字节流

（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构

（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。

相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为我们可以使用系统的类加载器加载，还可以使用自己的类加载器加载。

总结下，加载就是把java字节码数据加载到jvm内存当中，并映射成jvm认可的数据结构。

- 双亲委派： 防止一个类在jvm加载多次，父类先加载，加载不到在子类加载

- 打破双亲委派:集成classLoad类，重写loadClass方法

## 2、连接
### 2.1 验证
>保证被加载类的正确性
- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

检查加载到的字节信息是否符合jvm规范。
### 2.2 准备
> 为类的静态变量分配内存，并赋初始值，半初始状态
### 2.3 解析
> 把类中的符号引用转换为直接引用
## 3.初始化
> 对类的静态变量，静态代码块执行初始化操作

## 一个对象从加载到jvm,到被GC清除,经历了什么？
- 1.创建一个对象，jvm首先需要到方法区去找对象的类型信息。然后再创建对象。
- 2.jvm要实例化一个对象，首先要在堆中先创建一个对象。  --> 半初始化状态
- 3.对象首先会分配在堆内存中新生代的Eden,然后经过一次Minor GC，对象如果存活，进会进入S区。在后续的每次GC中，如果对象一直存活，就会在S区来回拷贝，每移动一次，年龄+1.（多大年龄才会移入到老年代？默认15，可通过-xx:maxtenuringthreshold设置）
- 4.当方法执行结束后，栈中指针会先移除掉。
- 5.堆中的对象，经过Full GC，就会被标记为垃圾，然后被GC线程清理掉。

# 三、垃圾回收算法
>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。
垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！

## 1.引用计数法
堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1  
`缺点：循环引用无法检测`

## 2.可达性算法
从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。

在Java语言中，可作为GC Roots的对象包括下面几种：  
a) 虚拟机栈中引用的对象（栈帧中的本地变量表）；  
b) 方法区中类静态属性引用的对象；  
c) 方法区中常量引用的对象；  
d) 本地方法栈中JNI（Native方法）引用的对象。

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finapze()方法。当对象没有覆盖finapze()方法，或者finapze()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。程序中可以通过覆盖finapze()来一场"惊心动魄"的自我拯救过程，但是，这只有一次机会呦。
## 3.标记-清除算法（Mark-Sweep）
标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间  
`耗时，产生大量不连续内存碎片`

## 4.复制算法(Copying)
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。  
`能够使用的内存缩减到原来的一半`  
`如果存活对象很多，那么Copying算法的效率将会大大降低`
## 5.标记-整理算法(Mark-compact)
该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动(记住是完成标记之后，先不清理，先移动再清理回收对象)，然后清理掉端边界以外的内存。
## 6分代收集
一般把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法
在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记一整理”算法来进行回收

>新生代采用复制算法  
新生代中的对象 98%是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。 Survivor from 和Survivor to ，内存比例 8：1：1
当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1, 也就是每次新生代中可用内存空间为整个新生代容量的 90% (80%+10%），只有 10% 的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10%的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

# 三、垃圾回收器

>jdk8环境下，默认使用 Parallel Scavenge（新生代）+ Serial Old（老年代）

## serial收集器

单线程的回收器，串行 复制算法
“Stop The World”，它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

## ParNew收集器
ParNew 收集器其实就是 Serial 收集器的多线程版本

## Parallel Scavenge收集器
使用复制算法的收集器，又是并行的多线程收集器。由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器  
吞吐量是什么？CPU用于运行用户代码的时间与CPU总时间的比值，99%时间执行用户线程，1%时间回收垃圾 ，这时候吞吐量就是99%


## Serial Old收集器
同Serial，单线程，算法采用 标记整理

## cms收集器
CMS (Concurrent Mark Sweep）收集器是-种以获取最短回收停顿时间为目标的收集器
CMS 收集器是基于“标记-清除”算法实现的。

步骤流程：
- 初始标记（CMS initial mark) -----标记一下 GC Roots 能直接关联到的对象，速度很快
- 并发标记（CMS concurrent mark --------并发标记阶段就是进行 GC RootsTracing 的过程
- 重新标记（CMS remark) -----------为了修正并发标记期间因用户程序导致标记产生变动的标记记录
- 并发清除（CMS concurrent sweep)

CMS垃圾收集器缺点
- 对CPU资源非常敏感
- 无法处理浮动垃圾，程序在进行并发清除阶段用户线程所产生的新垃圾
- 标记-清除存在空间碎片

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5069539f8614d8ab4fcf9c5a59c7afa~tplv-k3u1fbpfcp-watermark.image?)

## G1收集器
G1是一款面向服务端应用的垃圾收集器  
G1 中每个 Region 都有一个与之对应的 Remembered Set，当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏 检查Reference引用的对象是否处于不同的Region

- 初始标记（Initial Marking） --标记一下 GC Roots 能直接关联到的对象
- 并发标记（Concurrent Marking）---从GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行
- 最终标记（Final Marking)  ---为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录。虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 	里面，最终标记阶段需要把 Remembered Set Logs的数据合并到 Remembered Set 中
- 筛选回收（Live Data Counting and Evacuation)对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划


### G1的优势有哪些

- 空间整合：基于“标记一整理”算法实现为主和Region之间采用复制算法实现的垃圾收集
- 可预测的停顿：这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型

  在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔髙的了，它们都是一部分 Region（不需要连续）的集合。  
  G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Regions 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage- Firsti 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高

# GC是什么时候触发的
Scavenge GC  
一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

Full GC  
对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：

a) 年老代（Tenured）被写满；

b) 持久代（Perm）被写满；

c) System.gc()被显示调用；

d) 上一次GC之后Heap的各域分配策略动态变化；

## 逃逸分析
>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸

## 栈上分配
>栈上分配就是把方法中的变量和对象分配到栈上，方法执行完后自动销毁，而不需要垃圾回收的介入，从而提高系统性能  
-XX:+DoEscapeAnalysis开启逃逸分析（jdk1.8默认开启，其它版本未测试）  
-XX:-DoEscapeAnalysis 关闭逃逸分析



## GC 优化需要考虑的 JVM 参数

类型	参数	描述  
堆内存大小	-Xms	启动 JVM 时堆内存的大小  
-Xmx	堆内存最大限制  
新生代空间大小	-XX:NewRatio	新生代和老年代的内存比  
-XX:NewSize	新生代内存大小  
-XX:SurvivorRatio	Eden 区和 Survivor 区的内存比

